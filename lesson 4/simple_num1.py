#!/usr/bin/env python
# coding: utf-8

# In[ ]:


import timeit,cProfile
def simple_num(n):
    #число a нужно для сокращения времени выполнения каждого цикла при больших n
    a=int(n//100)+1
    #z - для определения начала проверки чисел при повторении цикла
    z=1
    # это будущий список; первое простое число = 2
    listx=[2]

    # и пока список не разрастется до указанного пользователем размера
    # использование n+1 связано с тем, что первый элемент у нас уже есть (=2)
    while len(listx)<n:
        #добавляем элементы
        for i in range(listx[-1]+1,a):
            # если число делится на 2, оно точно не простое - не добавляем
            if i%2!=0:
                #остальные добавили
                listx.append(i)
                # и проверям: все числа в списке, следующие после индекса z
                for up in listx[z:]:
                    # сравниваем с предыдущими
                    for k in listx[:z]:
                        # и если они делятся на них без остатка
                        if up%k==0:
                            # (если они уже не удалены, конечно)
                            if up in listx:
                                # я их удаляю
                                listx.remove(up)
                # запоминаем индекс последнего проверенного элемента, чтобы повторно не проверять
        z=listx.index(listx[-1])
        a+=int(n//100)
    #число с индексом = n-1 - наше искомое число
    return listx[n-1]

simple_num(1000)
#print(timeit.timeit(simple_num, number=1))
#cProfile.run('simple_num(10000)')
#В задачах с поиском простого числа по номеру этого числа алгоритм, разработанный на уроке
#проявил себя лучше, чем второй, который выполняется методом перебора. Время выполнения
#задачи первого кода растет примерно на 1 порядок при увеличении номера искомого числа в 10
#раз. А второй код растет примерно в 100 раз при увеличении номера элемента в 10 раз. Таким
#образом, время работы первого алгоритма выражается О(n), а второго – О(n 2 ). При этом,
#количество вызовов функций в первом случае растет незначительно , а во втором – не растет
#вообще.

# In[ ]:




